Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    NEWLINE

Grammar

Rule 0     S' -> Exp
Rule 1     Exp -> Term
Rule 2     Exp -> Term Binop
Rule 3     Exp -> Term Binop Exp
Rule 4     Exp -> IF Exp THEN Exp ELSE Exp
Rule 5     Exp -> LET MultiDef IN Exp
Rule 6     Exp -> MAP IdList TO Exp
Rule 7     Term -> Unop Term
Rule 8     Term -> Factor
Rule 9     Term -> Factor SPAR ExpList EPAR
Rule 10    Term -> Empty
Rule 11    Term -> INT
Rule 12    Term -> Bool
Rule 13    Factor -> SPAR Exp EPAR
Rule 14    Factor -> Prim
Rule 15    Factor -> ID
Rule 16    ExpList -> PropExpList
Rule 17    PropExpList -> Exp
Rule 18    PropExpList -> Exp COMA PropExpList
Rule 19    IdList -> PropIdList
Rule 20    PropIdList -> ID
Rule 21    PropIdList -> ID COMA PropIdList
Rule 22    Def -> ID ASSIGN Exp SEMI
Rule 23    Empty -> empty
Rule 24    Bool -> TRUE
Rule 25    Bool -> FALSE
Rule 26    Unop -> Sign
Rule 27    Unop -> APROX
Rule 28    Sign -> PLUS
Rule 29    Sign -> MINUS
Rule 30    Binop -> Sign
Rule 31    Binop -> SYMBOL
Rule 32    Prim -> NUMQ
Rule 33    Prim -> FUNCTQ
Rule 34    Prim -> LISTQ
Rule 35    Prim -> EMPTYQ
Rule 36    Prim -> CONSQ
Rule 37    Prim -> CONS
Rule 38    Prim -> FIRST
Rule 39    Prim -> REST
Rule 40    Prim -> ARITY
Rule 41    empty -> <empty>
Rule 42    MultiDef -> Def
Rule 43    MultiDef -> Def MultiDef

Terminals, with rules where they appear

APROX                : 27
ARITY                : 40
ASSIGN               : 22
COMA                 : 18 21
CONS                 : 37
CONSQ                : 36
ELSE                 : 4
EMPTYQ               : 35
EPAR                 : 9 13
FALSE                : 25
FIRST                : 38
FUNCTQ               : 33
ID                   : 15 20 21 22
IF                   : 4
IN                   : 5
INT                  : 11
LET                  : 5
LISTQ                : 34
MAP                  : 6
MINUS                : 29
NEWLINE              : 
NUMQ                 : 32
PLUS                 : 28
REST                 : 39
SEMI                 : 22
SPAR                 : 9 13
SYMBOL               : 31
THEN                 : 4
TO                   : 6
TRUE                 : 24
error                : 

Nonterminals, with rules where they appear

Binop                : 2 3
Bool                 : 12
Def                  : 42 43
Empty                : 10
Exp                  : 3 4 4 4 5 6 13 17 18 22 0
ExpList              : 9
Factor               : 8 9
IdList               : 6
MultiDef             : 5 43
Prim                 : 14
PropExpList          : 16 18
PropIdList           : 19 21
Sign                 : 26 30
Term                 : 1 2 3 7
Unop                 : 7
empty                : 23

Parsing method: LALR

state 0

    (0) S' -> . Exp
    (1) Exp -> . Term
    (2) Exp -> . Term Binop
    (3) Exp -> . Term Binop Exp
    (4) Exp -> . IF Exp THEN Exp ELSE Exp
    (5) Exp -> . LET MultiDef IN Exp
    (6) Exp -> . MAP IdList TO Exp
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)
    $end            reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]

    Exp                            shift and go to state 1
    Term                           shift and go to state 2
    Unop                           shift and go to state 6
    Factor                         shift and go to state 7
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 1

    (0) S' -> Exp .



state 2

    (1) Exp -> Term .
    (2) Exp -> Term . Binop
    (3) Exp -> Term . Binop Exp
    (30) Binop -> . Sign
    (31) Binop -> . SYMBOL
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS

    $end            reduce using rule 1 (Exp -> Term .)
    THEN            reduce using rule 1 (Exp -> Term .)
    EPAR            reduce using rule 1 (Exp -> Term .)
    COMA            reduce using rule 1 (Exp -> Term .)
    ELSE            reduce using rule 1 (Exp -> Term .)
    SEMI            reduce using rule 1 (Exp -> Term .)
    SYMBOL          shift and go to state 32
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20

    Binop                          shift and go to state 30
    Sign                           shift and go to state 31

state 3

    (4) Exp -> IF . Exp THEN Exp ELSE Exp
    (1) Exp -> . Term
    (2) Exp -> . Term Binop
    (3) Exp -> . Term Binop Exp
    (4) Exp -> . IF Exp THEN Exp ELSE Exp
    (5) Exp -> . LET MultiDef IN Exp
    (6) Exp -> . MAP IdList TO Exp
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)
    THEN            reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]

    Exp                            shift and go to state 33
    Term                           shift and go to state 2
    Unop                           shift and go to state 6
    Factor                         shift and go to state 7
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 4

    (5) Exp -> LET . MultiDef IN Exp
    (42) MultiDef -> . Def
    (43) MultiDef -> . Def MultiDef
    (22) Def -> . ID ASSIGN Exp SEMI

    ID              shift and go to state 36

    MultiDef                       shift and go to state 34
    Def                            shift and go to state 35

state 5

    (6) Exp -> MAP . IdList TO Exp
    (19) IdList -> . PropIdList
    (20) PropIdList -> . ID
    (21) PropIdList -> . ID COMA PropIdList

    ID              shift and go to state 39

    IdList                         shift and go to state 37
    PropIdList                     shift and go to state 38

state 6

    (7) Term -> Unop . Term
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)
    $end            reduce using rule 41 (empty -> .)
    THEN            reduce using rule 41 (empty -> .)
    EPAR            reduce using rule 41 (empty -> .)
    COMA            reduce using rule 41 (empty -> .)
    ELSE            reduce using rule 41 (empty -> .)
    SEMI            reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]

    Unop                           shift and go to state 6
    Term                           shift and go to state 40
    Factor                         shift and go to state 7
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 7

    (8) Term -> Factor .
    (9) Term -> Factor . SPAR ExpList EPAR

    SYMBOL          reduce using rule 8 (Term -> Factor .)
    PLUS            reduce using rule 8 (Term -> Factor .)
    MINUS           reduce using rule 8 (Term -> Factor .)
    $end            reduce using rule 8 (Term -> Factor .)
    THEN            reduce using rule 8 (Term -> Factor .)
    EPAR            reduce using rule 8 (Term -> Factor .)
    COMA            reduce using rule 8 (Term -> Factor .)
    ELSE            reduce using rule 8 (Term -> Factor .)
    SEMI            reduce using rule 8 (Term -> Factor .)
    SPAR            shift and go to state 41


state 8

    (13) Factor -> SPAR . Exp EPAR
    (1) Exp -> . Term
    (2) Exp -> . Term Binop
    (3) Exp -> . Term Binop Exp
    (4) Exp -> . IF Exp THEN Exp ELSE Exp
    (5) Exp -> . LET MultiDef IN Exp
    (6) Exp -> . MAP IdList TO Exp
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)
    EPAR            reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]

    Exp                            shift and go to state 42
    Term                           shift and go to state 2
    Unop                           shift and go to state 6
    Factor                         shift and go to state 7
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 9

    (10) Term -> Empty .

    SYMBOL          reduce using rule 10 (Term -> Empty .)
    PLUS            reduce using rule 10 (Term -> Empty .)
    MINUS           reduce using rule 10 (Term -> Empty .)
    $end            reduce using rule 10 (Term -> Empty .)
    THEN            reduce using rule 10 (Term -> Empty .)
    EPAR            reduce using rule 10 (Term -> Empty .)
    COMA            reduce using rule 10 (Term -> Empty .)
    ELSE            reduce using rule 10 (Term -> Empty .)
    SEMI            reduce using rule 10 (Term -> Empty .)


state 10

    (11) Term -> INT .

    SYMBOL          reduce using rule 11 (Term -> INT .)
    PLUS            reduce using rule 11 (Term -> INT .)
    MINUS           reduce using rule 11 (Term -> INT .)
    $end            reduce using rule 11 (Term -> INT .)
    THEN            reduce using rule 11 (Term -> INT .)
    EPAR            reduce using rule 11 (Term -> INT .)
    COMA            reduce using rule 11 (Term -> INT .)
    ELSE            reduce using rule 11 (Term -> INT .)
    SEMI            reduce using rule 11 (Term -> INT .)


state 11

    (12) Term -> Bool .

    SYMBOL          reduce using rule 12 (Term -> Bool .)
    PLUS            reduce using rule 12 (Term -> Bool .)
    MINUS           reduce using rule 12 (Term -> Bool .)
    $end            reduce using rule 12 (Term -> Bool .)
    THEN            reduce using rule 12 (Term -> Bool .)
    EPAR            reduce using rule 12 (Term -> Bool .)
    COMA            reduce using rule 12 (Term -> Bool .)
    ELSE            reduce using rule 12 (Term -> Bool .)
    SEMI            reduce using rule 12 (Term -> Bool .)


state 12

    (26) Unop -> Sign .

    INT             reduce using rule 26 (Unop -> Sign .)
    APROX           reduce using rule 26 (Unop -> Sign .)
    SPAR            reduce using rule 26 (Unop -> Sign .)
    ID              reduce using rule 26 (Unop -> Sign .)
    TRUE            reduce using rule 26 (Unop -> Sign .)
    FALSE           reduce using rule 26 (Unop -> Sign .)
    PLUS            reduce using rule 26 (Unop -> Sign .)
    MINUS           reduce using rule 26 (Unop -> Sign .)
    NUMQ            reduce using rule 26 (Unop -> Sign .)
    FUNCTQ          reduce using rule 26 (Unop -> Sign .)
    LISTQ           reduce using rule 26 (Unop -> Sign .)
    EMPTYQ          reduce using rule 26 (Unop -> Sign .)
    CONSQ           reduce using rule 26 (Unop -> Sign .)
    CONS            reduce using rule 26 (Unop -> Sign .)
    FIRST           reduce using rule 26 (Unop -> Sign .)
    REST            reduce using rule 26 (Unop -> Sign .)
    ARITY           reduce using rule 26 (Unop -> Sign .)
    SYMBOL          reduce using rule 26 (Unop -> Sign .)
    $end            reduce using rule 26 (Unop -> Sign .)
    THEN            reduce using rule 26 (Unop -> Sign .)
    EPAR            reduce using rule 26 (Unop -> Sign .)
    COMA            reduce using rule 26 (Unop -> Sign .)
    ELSE            reduce using rule 26 (Unop -> Sign .)
    SEMI            reduce using rule 26 (Unop -> Sign .)


state 13

    (27) Unop -> APROX .

    INT             reduce using rule 27 (Unop -> APROX .)
    APROX           reduce using rule 27 (Unop -> APROX .)
    SPAR            reduce using rule 27 (Unop -> APROX .)
    ID              reduce using rule 27 (Unop -> APROX .)
    TRUE            reduce using rule 27 (Unop -> APROX .)
    FALSE           reduce using rule 27 (Unop -> APROX .)
    PLUS            reduce using rule 27 (Unop -> APROX .)
    MINUS           reduce using rule 27 (Unop -> APROX .)
    NUMQ            reduce using rule 27 (Unop -> APROX .)
    FUNCTQ          reduce using rule 27 (Unop -> APROX .)
    LISTQ           reduce using rule 27 (Unop -> APROX .)
    EMPTYQ          reduce using rule 27 (Unop -> APROX .)
    CONSQ           reduce using rule 27 (Unop -> APROX .)
    CONS            reduce using rule 27 (Unop -> APROX .)
    FIRST           reduce using rule 27 (Unop -> APROX .)
    REST            reduce using rule 27 (Unop -> APROX .)
    ARITY           reduce using rule 27 (Unop -> APROX .)
    SYMBOL          reduce using rule 27 (Unop -> APROX .)
    $end            reduce using rule 27 (Unop -> APROX .)
    THEN            reduce using rule 27 (Unop -> APROX .)
    EPAR            reduce using rule 27 (Unop -> APROX .)
    COMA            reduce using rule 27 (Unop -> APROX .)
    ELSE            reduce using rule 27 (Unop -> APROX .)
    SEMI            reduce using rule 27 (Unop -> APROX .)


state 14

    (14) Factor -> Prim .

    SPAR            reduce using rule 14 (Factor -> Prim .)
    SYMBOL          reduce using rule 14 (Factor -> Prim .)
    PLUS            reduce using rule 14 (Factor -> Prim .)
    MINUS           reduce using rule 14 (Factor -> Prim .)
    $end            reduce using rule 14 (Factor -> Prim .)
    THEN            reduce using rule 14 (Factor -> Prim .)
    EPAR            reduce using rule 14 (Factor -> Prim .)
    COMA            reduce using rule 14 (Factor -> Prim .)
    ELSE            reduce using rule 14 (Factor -> Prim .)
    SEMI            reduce using rule 14 (Factor -> Prim .)


state 15

    (15) Factor -> ID .

    SPAR            reduce using rule 15 (Factor -> ID .)
    SYMBOL          reduce using rule 15 (Factor -> ID .)
    PLUS            reduce using rule 15 (Factor -> ID .)
    MINUS           reduce using rule 15 (Factor -> ID .)
    $end            reduce using rule 15 (Factor -> ID .)
    THEN            reduce using rule 15 (Factor -> ID .)
    EPAR            reduce using rule 15 (Factor -> ID .)
    COMA            reduce using rule 15 (Factor -> ID .)
    ELSE            reduce using rule 15 (Factor -> ID .)
    SEMI            reduce using rule 15 (Factor -> ID .)


state 16

    (23) Empty -> empty .

    SYMBOL          reduce using rule 23 (Empty -> empty .)
    PLUS            reduce using rule 23 (Empty -> empty .)
    MINUS           reduce using rule 23 (Empty -> empty .)
    $end            reduce using rule 23 (Empty -> empty .)
    THEN            reduce using rule 23 (Empty -> empty .)
    EPAR            reduce using rule 23 (Empty -> empty .)
    COMA            reduce using rule 23 (Empty -> empty .)
    ELSE            reduce using rule 23 (Empty -> empty .)
    SEMI            reduce using rule 23 (Empty -> empty .)


state 17

    (24) Bool -> TRUE .

    SYMBOL          reduce using rule 24 (Bool -> TRUE .)
    PLUS            reduce using rule 24 (Bool -> TRUE .)
    MINUS           reduce using rule 24 (Bool -> TRUE .)
    $end            reduce using rule 24 (Bool -> TRUE .)
    THEN            reduce using rule 24 (Bool -> TRUE .)
    EPAR            reduce using rule 24 (Bool -> TRUE .)
    COMA            reduce using rule 24 (Bool -> TRUE .)
    ELSE            reduce using rule 24 (Bool -> TRUE .)
    SEMI            reduce using rule 24 (Bool -> TRUE .)


state 18

    (25) Bool -> FALSE .

    SYMBOL          reduce using rule 25 (Bool -> FALSE .)
    PLUS            reduce using rule 25 (Bool -> FALSE .)
    MINUS           reduce using rule 25 (Bool -> FALSE .)
    $end            reduce using rule 25 (Bool -> FALSE .)
    THEN            reduce using rule 25 (Bool -> FALSE .)
    EPAR            reduce using rule 25 (Bool -> FALSE .)
    COMA            reduce using rule 25 (Bool -> FALSE .)
    ELSE            reduce using rule 25 (Bool -> FALSE .)
    SEMI            reduce using rule 25 (Bool -> FALSE .)


state 19

    (28) Sign -> PLUS .

    INT             reduce using rule 28 (Sign -> PLUS .)
    APROX           reduce using rule 28 (Sign -> PLUS .)
    SPAR            reduce using rule 28 (Sign -> PLUS .)
    ID              reduce using rule 28 (Sign -> PLUS .)
    TRUE            reduce using rule 28 (Sign -> PLUS .)
    FALSE           reduce using rule 28 (Sign -> PLUS .)
    PLUS            reduce using rule 28 (Sign -> PLUS .)
    MINUS           reduce using rule 28 (Sign -> PLUS .)
    NUMQ            reduce using rule 28 (Sign -> PLUS .)
    FUNCTQ          reduce using rule 28 (Sign -> PLUS .)
    LISTQ           reduce using rule 28 (Sign -> PLUS .)
    EMPTYQ          reduce using rule 28 (Sign -> PLUS .)
    CONSQ           reduce using rule 28 (Sign -> PLUS .)
    CONS            reduce using rule 28 (Sign -> PLUS .)
    FIRST           reduce using rule 28 (Sign -> PLUS .)
    REST            reduce using rule 28 (Sign -> PLUS .)
    ARITY           reduce using rule 28 (Sign -> PLUS .)
    SYMBOL          reduce using rule 28 (Sign -> PLUS .)
    $end            reduce using rule 28 (Sign -> PLUS .)
    IF              reduce using rule 28 (Sign -> PLUS .)
    LET             reduce using rule 28 (Sign -> PLUS .)
    MAP             reduce using rule 28 (Sign -> PLUS .)
    THEN            reduce using rule 28 (Sign -> PLUS .)
    EPAR            reduce using rule 28 (Sign -> PLUS .)
    COMA            reduce using rule 28 (Sign -> PLUS .)
    ELSE            reduce using rule 28 (Sign -> PLUS .)
    SEMI            reduce using rule 28 (Sign -> PLUS .)


state 20

    (29) Sign -> MINUS .

    INT             reduce using rule 29 (Sign -> MINUS .)
    APROX           reduce using rule 29 (Sign -> MINUS .)
    SPAR            reduce using rule 29 (Sign -> MINUS .)
    ID              reduce using rule 29 (Sign -> MINUS .)
    TRUE            reduce using rule 29 (Sign -> MINUS .)
    FALSE           reduce using rule 29 (Sign -> MINUS .)
    PLUS            reduce using rule 29 (Sign -> MINUS .)
    MINUS           reduce using rule 29 (Sign -> MINUS .)
    NUMQ            reduce using rule 29 (Sign -> MINUS .)
    FUNCTQ          reduce using rule 29 (Sign -> MINUS .)
    LISTQ           reduce using rule 29 (Sign -> MINUS .)
    EMPTYQ          reduce using rule 29 (Sign -> MINUS .)
    CONSQ           reduce using rule 29 (Sign -> MINUS .)
    CONS            reduce using rule 29 (Sign -> MINUS .)
    FIRST           reduce using rule 29 (Sign -> MINUS .)
    REST            reduce using rule 29 (Sign -> MINUS .)
    ARITY           reduce using rule 29 (Sign -> MINUS .)
    SYMBOL          reduce using rule 29 (Sign -> MINUS .)
    $end            reduce using rule 29 (Sign -> MINUS .)
    IF              reduce using rule 29 (Sign -> MINUS .)
    LET             reduce using rule 29 (Sign -> MINUS .)
    MAP             reduce using rule 29 (Sign -> MINUS .)
    THEN            reduce using rule 29 (Sign -> MINUS .)
    EPAR            reduce using rule 29 (Sign -> MINUS .)
    COMA            reduce using rule 29 (Sign -> MINUS .)
    ELSE            reduce using rule 29 (Sign -> MINUS .)
    SEMI            reduce using rule 29 (Sign -> MINUS .)


state 21

    (32) Prim -> NUMQ .

    SPAR            reduce using rule 32 (Prim -> NUMQ .)
    SYMBOL          reduce using rule 32 (Prim -> NUMQ .)
    PLUS            reduce using rule 32 (Prim -> NUMQ .)
    MINUS           reduce using rule 32 (Prim -> NUMQ .)
    $end            reduce using rule 32 (Prim -> NUMQ .)
    THEN            reduce using rule 32 (Prim -> NUMQ .)
    EPAR            reduce using rule 32 (Prim -> NUMQ .)
    COMA            reduce using rule 32 (Prim -> NUMQ .)
    ELSE            reduce using rule 32 (Prim -> NUMQ .)
    SEMI            reduce using rule 32 (Prim -> NUMQ .)


state 22

    (33) Prim -> FUNCTQ .

    SPAR            reduce using rule 33 (Prim -> FUNCTQ .)
    SYMBOL          reduce using rule 33 (Prim -> FUNCTQ .)
    PLUS            reduce using rule 33 (Prim -> FUNCTQ .)
    MINUS           reduce using rule 33 (Prim -> FUNCTQ .)
    $end            reduce using rule 33 (Prim -> FUNCTQ .)
    THEN            reduce using rule 33 (Prim -> FUNCTQ .)
    EPAR            reduce using rule 33 (Prim -> FUNCTQ .)
    COMA            reduce using rule 33 (Prim -> FUNCTQ .)
    ELSE            reduce using rule 33 (Prim -> FUNCTQ .)
    SEMI            reduce using rule 33 (Prim -> FUNCTQ .)


state 23

    (34) Prim -> LISTQ .

    SPAR            reduce using rule 34 (Prim -> LISTQ .)
    SYMBOL          reduce using rule 34 (Prim -> LISTQ .)
    PLUS            reduce using rule 34 (Prim -> LISTQ .)
    MINUS           reduce using rule 34 (Prim -> LISTQ .)
    $end            reduce using rule 34 (Prim -> LISTQ .)
    THEN            reduce using rule 34 (Prim -> LISTQ .)
    EPAR            reduce using rule 34 (Prim -> LISTQ .)
    COMA            reduce using rule 34 (Prim -> LISTQ .)
    ELSE            reduce using rule 34 (Prim -> LISTQ .)
    SEMI            reduce using rule 34 (Prim -> LISTQ .)


state 24

    (35) Prim -> EMPTYQ .

    SPAR            reduce using rule 35 (Prim -> EMPTYQ .)
    SYMBOL          reduce using rule 35 (Prim -> EMPTYQ .)
    PLUS            reduce using rule 35 (Prim -> EMPTYQ .)
    MINUS           reduce using rule 35 (Prim -> EMPTYQ .)
    $end            reduce using rule 35 (Prim -> EMPTYQ .)
    THEN            reduce using rule 35 (Prim -> EMPTYQ .)
    EPAR            reduce using rule 35 (Prim -> EMPTYQ .)
    COMA            reduce using rule 35 (Prim -> EMPTYQ .)
    ELSE            reduce using rule 35 (Prim -> EMPTYQ .)
    SEMI            reduce using rule 35 (Prim -> EMPTYQ .)


state 25

    (36) Prim -> CONSQ .

    SPAR            reduce using rule 36 (Prim -> CONSQ .)
    SYMBOL          reduce using rule 36 (Prim -> CONSQ .)
    PLUS            reduce using rule 36 (Prim -> CONSQ .)
    MINUS           reduce using rule 36 (Prim -> CONSQ .)
    $end            reduce using rule 36 (Prim -> CONSQ .)
    THEN            reduce using rule 36 (Prim -> CONSQ .)
    EPAR            reduce using rule 36 (Prim -> CONSQ .)
    COMA            reduce using rule 36 (Prim -> CONSQ .)
    ELSE            reduce using rule 36 (Prim -> CONSQ .)
    SEMI            reduce using rule 36 (Prim -> CONSQ .)


state 26

    (37) Prim -> CONS .

    SPAR            reduce using rule 37 (Prim -> CONS .)
    SYMBOL          reduce using rule 37 (Prim -> CONS .)
    PLUS            reduce using rule 37 (Prim -> CONS .)
    MINUS           reduce using rule 37 (Prim -> CONS .)
    $end            reduce using rule 37 (Prim -> CONS .)
    THEN            reduce using rule 37 (Prim -> CONS .)
    EPAR            reduce using rule 37 (Prim -> CONS .)
    COMA            reduce using rule 37 (Prim -> CONS .)
    ELSE            reduce using rule 37 (Prim -> CONS .)
    SEMI            reduce using rule 37 (Prim -> CONS .)


state 27

    (38) Prim -> FIRST .

    SPAR            reduce using rule 38 (Prim -> FIRST .)
    SYMBOL          reduce using rule 38 (Prim -> FIRST .)
    PLUS            reduce using rule 38 (Prim -> FIRST .)
    MINUS           reduce using rule 38 (Prim -> FIRST .)
    $end            reduce using rule 38 (Prim -> FIRST .)
    THEN            reduce using rule 38 (Prim -> FIRST .)
    EPAR            reduce using rule 38 (Prim -> FIRST .)
    COMA            reduce using rule 38 (Prim -> FIRST .)
    ELSE            reduce using rule 38 (Prim -> FIRST .)
    SEMI            reduce using rule 38 (Prim -> FIRST .)


state 28

    (39) Prim -> REST .

    SPAR            reduce using rule 39 (Prim -> REST .)
    SYMBOL          reduce using rule 39 (Prim -> REST .)
    PLUS            reduce using rule 39 (Prim -> REST .)
    MINUS           reduce using rule 39 (Prim -> REST .)
    $end            reduce using rule 39 (Prim -> REST .)
    THEN            reduce using rule 39 (Prim -> REST .)
    EPAR            reduce using rule 39 (Prim -> REST .)
    COMA            reduce using rule 39 (Prim -> REST .)
    ELSE            reduce using rule 39 (Prim -> REST .)
    SEMI            reduce using rule 39 (Prim -> REST .)


state 29

    (40) Prim -> ARITY .

    SPAR            reduce using rule 40 (Prim -> ARITY .)
    SYMBOL          reduce using rule 40 (Prim -> ARITY .)
    PLUS            reduce using rule 40 (Prim -> ARITY .)
    MINUS           reduce using rule 40 (Prim -> ARITY .)
    $end            reduce using rule 40 (Prim -> ARITY .)
    THEN            reduce using rule 40 (Prim -> ARITY .)
    EPAR            reduce using rule 40 (Prim -> ARITY .)
    COMA            reduce using rule 40 (Prim -> ARITY .)
    ELSE            reduce using rule 40 (Prim -> ARITY .)
    SEMI            reduce using rule 40 (Prim -> ARITY .)


state 30

    (2) Exp -> Term Binop .
    (3) Exp -> Term Binop . Exp
    (1) Exp -> . Term
    (2) Exp -> . Term Binop
    (3) Exp -> . Term Binop Exp
    (4) Exp -> . IF Exp THEN Exp ELSE Exp
    (5) Exp -> . LET MultiDef IN Exp
    (6) Exp -> . MAP IdList TO Exp
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 2 (Exp -> Term Binop .)
  ! reduce/reduce conflict for THEN resolved using rule 2 (Exp -> Term Binop .)
  ! reduce/reduce conflict for EPAR resolved using rule 2 (Exp -> Term Binop .)
  ! reduce/reduce conflict for COMA resolved using rule 2 (Exp -> Term Binop .)
  ! reduce/reduce conflict for ELSE resolved using rule 2 (Exp -> Term Binop .)
  ! reduce/reduce conflict for SEMI resolved using rule 2 (Exp -> Term Binop .)
    $end            reduce using rule 2 (Exp -> Term Binop .)
    THEN            reduce using rule 2 (Exp -> Term Binop .)
    EPAR            reduce using rule 2 (Exp -> Term Binop .)
    COMA            reduce using rule 2 (Exp -> Term Binop .)
    ELSE            reduce using rule 2 (Exp -> Term Binop .)
    SEMI            reduce using rule 2 (Exp -> Term Binop .)
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]
  ! $end            [ reduce using rule 41 (empty -> .) ]
  ! THEN            [ reduce using rule 41 (empty -> .) ]
  ! EPAR            [ reduce using rule 41 (empty -> .) ]
  ! COMA            [ reduce using rule 41 (empty -> .) ]
  ! ELSE            [ reduce using rule 41 (empty -> .) ]
  ! SEMI            [ reduce using rule 41 (empty -> .) ]

    Term                           shift and go to state 2
    Exp                            shift and go to state 43
    Unop                           shift and go to state 6
    Factor                         shift and go to state 7
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 31

    (30) Binop -> Sign .

    IF              reduce using rule 30 (Binop -> Sign .)
    LET             reduce using rule 30 (Binop -> Sign .)
    MAP             reduce using rule 30 (Binop -> Sign .)
    INT             reduce using rule 30 (Binop -> Sign .)
    APROX           reduce using rule 30 (Binop -> Sign .)
    SPAR            reduce using rule 30 (Binop -> Sign .)
    ID              reduce using rule 30 (Binop -> Sign .)
    TRUE            reduce using rule 30 (Binop -> Sign .)
    FALSE           reduce using rule 30 (Binop -> Sign .)
    PLUS            reduce using rule 30 (Binop -> Sign .)
    MINUS           reduce using rule 30 (Binop -> Sign .)
    NUMQ            reduce using rule 30 (Binop -> Sign .)
    FUNCTQ          reduce using rule 30 (Binop -> Sign .)
    LISTQ           reduce using rule 30 (Binop -> Sign .)
    EMPTYQ          reduce using rule 30 (Binop -> Sign .)
    CONSQ           reduce using rule 30 (Binop -> Sign .)
    CONS            reduce using rule 30 (Binop -> Sign .)
    FIRST           reduce using rule 30 (Binop -> Sign .)
    REST            reduce using rule 30 (Binop -> Sign .)
    ARITY           reduce using rule 30 (Binop -> Sign .)
    SYMBOL          reduce using rule 30 (Binop -> Sign .)
    $end            reduce using rule 30 (Binop -> Sign .)
    THEN            reduce using rule 30 (Binop -> Sign .)
    EPAR            reduce using rule 30 (Binop -> Sign .)
    COMA            reduce using rule 30 (Binop -> Sign .)
    ELSE            reduce using rule 30 (Binop -> Sign .)
    SEMI            reduce using rule 30 (Binop -> Sign .)


state 32

    (31) Binop -> SYMBOL .

    IF              reduce using rule 31 (Binop -> SYMBOL .)
    LET             reduce using rule 31 (Binop -> SYMBOL .)
    MAP             reduce using rule 31 (Binop -> SYMBOL .)
    INT             reduce using rule 31 (Binop -> SYMBOL .)
    APROX           reduce using rule 31 (Binop -> SYMBOL .)
    SPAR            reduce using rule 31 (Binop -> SYMBOL .)
    ID              reduce using rule 31 (Binop -> SYMBOL .)
    TRUE            reduce using rule 31 (Binop -> SYMBOL .)
    FALSE           reduce using rule 31 (Binop -> SYMBOL .)
    PLUS            reduce using rule 31 (Binop -> SYMBOL .)
    MINUS           reduce using rule 31 (Binop -> SYMBOL .)
    NUMQ            reduce using rule 31 (Binop -> SYMBOL .)
    FUNCTQ          reduce using rule 31 (Binop -> SYMBOL .)
    LISTQ           reduce using rule 31 (Binop -> SYMBOL .)
    EMPTYQ          reduce using rule 31 (Binop -> SYMBOL .)
    CONSQ           reduce using rule 31 (Binop -> SYMBOL .)
    CONS            reduce using rule 31 (Binop -> SYMBOL .)
    FIRST           reduce using rule 31 (Binop -> SYMBOL .)
    REST            reduce using rule 31 (Binop -> SYMBOL .)
    ARITY           reduce using rule 31 (Binop -> SYMBOL .)
    SYMBOL          reduce using rule 31 (Binop -> SYMBOL .)
    $end            reduce using rule 31 (Binop -> SYMBOL .)
    THEN            reduce using rule 31 (Binop -> SYMBOL .)
    EPAR            reduce using rule 31 (Binop -> SYMBOL .)
    COMA            reduce using rule 31 (Binop -> SYMBOL .)
    ELSE            reduce using rule 31 (Binop -> SYMBOL .)
    SEMI            reduce using rule 31 (Binop -> SYMBOL .)


state 33

    (4) Exp -> IF Exp . THEN Exp ELSE Exp

    THEN            shift and go to state 44


state 34

    (5) Exp -> LET MultiDef . IN Exp

    IN              shift and go to state 45


state 35

    (42) MultiDef -> Def .
    (43) MultiDef -> Def . MultiDef
    (42) MultiDef -> . Def
    (43) MultiDef -> . Def MultiDef
    (22) Def -> . ID ASSIGN Exp SEMI

    IN              reduce using rule 42 (MultiDef -> Def .)
    ID              shift and go to state 36

    Def                            shift and go to state 35
    MultiDef                       shift and go to state 46

state 36

    (22) Def -> ID . ASSIGN Exp SEMI

    ASSIGN          shift and go to state 47


state 37

    (6) Exp -> MAP IdList . TO Exp

    TO              shift and go to state 48


state 38

    (19) IdList -> PropIdList .

    TO              reduce using rule 19 (IdList -> PropIdList .)


state 39

    (20) PropIdList -> ID .
    (21) PropIdList -> ID . COMA PropIdList

    TO              reduce using rule 20 (PropIdList -> ID .)
    COMA            shift and go to state 49


state 40

    (7) Term -> Unop Term .

    SYMBOL          reduce using rule 7 (Term -> Unop Term .)
    PLUS            reduce using rule 7 (Term -> Unop Term .)
    MINUS           reduce using rule 7 (Term -> Unop Term .)
    $end            reduce using rule 7 (Term -> Unop Term .)
    THEN            reduce using rule 7 (Term -> Unop Term .)
    EPAR            reduce using rule 7 (Term -> Unop Term .)
    COMA            reduce using rule 7 (Term -> Unop Term .)
    ELSE            reduce using rule 7 (Term -> Unop Term .)
    SEMI            reduce using rule 7 (Term -> Unop Term .)


state 41

    (9) Term -> Factor SPAR . ExpList EPAR
    (16) ExpList -> . PropExpList
    (17) PropExpList -> . Exp
    (18) PropExpList -> . Exp COMA PropExpList
    (1) Exp -> . Term
    (2) Exp -> . Term Binop
    (3) Exp -> . Term Binop Exp
    (4) Exp -> . IF Exp THEN Exp ELSE Exp
    (5) Exp -> . LET MultiDef IN Exp
    (6) Exp -> . MAP IdList TO Exp
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)
    COMA            reduce using rule 41 (empty -> .)
    EPAR            reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]

    Factor                         shift and go to state 7
    ExpList                        shift and go to state 50
    PropExpList                    shift and go to state 51
    Exp                            shift and go to state 52
    Term                           shift and go to state 2
    Unop                           shift and go to state 6
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 42

    (13) Factor -> SPAR Exp . EPAR

    EPAR            shift and go to state 53


state 43

    (3) Exp -> Term Binop Exp .

    $end            reduce using rule 3 (Exp -> Term Binop Exp .)
    THEN            reduce using rule 3 (Exp -> Term Binop Exp .)
    EPAR            reduce using rule 3 (Exp -> Term Binop Exp .)
    COMA            reduce using rule 3 (Exp -> Term Binop Exp .)
    ELSE            reduce using rule 3 (Exp -> Term Binop Exp .)
    SEMI            reduce using rule 3 (Exp -> Term Binop Exp .)


state 44

    (4) Exp -> IF Exp THEN . Exp ELSE Exp
    (1) Exp -> . Term
    (2) Exp -> . Term Binop
    (3) Exp -> . Term Binop Exp
    (4) Exp -> . IF Exp THEN Exp ELSE Exp
    (5) Exp -> . LET MultiDef IN Exp
    (6) Exp -> . MAP IdList TO Exp
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)
    ELSE            reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]

    Exp                            shift and go to state 54
    Term                           shift and go to state 2
    Unop                           shift and go to state 6
    Factor                         shift and go to state 7
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 45

    (5) Exp -> LET MultiDef IN . Exp
    (1) Exp -> . Term
    (2) Exp -> . Term Binop
    (3) Exp -> . Term Binop Exp
    (4) Exp -> . IF Exp THEN Exp ELSE Exp
    (5) Exp -> . LET MultiDef IN Exp
    (6) Exp -> . MAP IdList TO Exp
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)
    $end            reduce using rule 41 (empty -> .)
    THEN            reduce using rule 41 (empty -> .)
    EPAR            reduce using rule 41 (empty -> .)
    COMA            reduce using rule 41 (empty -> .)
    ELSE            reduce using rule 41 (empty -> .)
    SEMI            reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]

    Exp                            shift and go to state 55
    Term                           shift and go to state 2
    Unop                           shift and go to state 6
    Factor                         shift and go to state 7
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 46

    (43) MultiDef -> Def MultiDef .

    IN              reduce using rule 43 (MultiDef -> Def MultiDef .)


state 47

    (22) Def -> ID ASSIGN . Exp SEMI
    (1) Exp -> . Term
    (2) Exp -> . Term Binop
    (3) Exp -> . Term Binop Exp
    (4) Exp -> . IF Exp THEN Exp ELSE Exp
    (5) Exp -> . LET MultiDef IN Exp
    (6) Exp -> . MAP IdList TO Exp
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)
    SEMI            reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]

    Exp                            shift and go to state 56
    Term                           shift and go to state 2
    Unop                           shift and go to state 6
    Factor                         shift and go to state 7
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 48

    (6) Exp -> MAP IdList TO . Exp
    (1) Exp -> . Term
    (2) Exp -> . Term Binop
    (3) Exp -> . Term Binop Exp
    (4) Exp -> . IF Exp THEN Exp ELSE Exp
    (5) Exp -> . LET MultiDef IN Exp
    (6) Exp -> . MAP IdList TO Exp
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)
    $end            reduce using rule 41 (empty -> .)
    THEN            reduce using rule 41 (empty -> .)
    EPAR            reduce using rule 41 (empty -> .)
    COMA            reduce using rule 41 (empty -> .)
    ELSE            reduce using rule 41 (empty -> .)
    SEMI            reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]

    Exp                            shift and go to state 57
    Term                           shift and go to state 2
    Unop                           shift and go to state 6
    Factor                         shift and go to state 7
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 49

    (21) PropIdList -> ID COMA . PropIdList
    (20) PropIdList -> . ID
    (21) PropIdList -> . ID COMA PropIdList

    ID              shift and go to state 39

    PropIdList                     shift and go to state 58

state 50

    (9) Term -> Factor SPAR ExpList . EPAR

    EPAR            shift and go to state 59


state 51

    (16) ExpList -> PropExpList .

    EPAR            reduce using rule 16 (ExpList -> PropExpList .)


state 52

    (17) PropExpList -> Exp .
    (18) PropExpList -> Exp . COMA PropExpList

    EPAR            reduce using rule 17 (PropExpList -> Exp .)
    COMA            shift and go to state 60


state 53

    (13) Factor -> SPAR Exp EPAR .

    SPAR            reduce using rule 13 (Factor -> SPAR Exp EPAR .)
    SYMBOL          reduce using rule 13 (Factor -> SPAR Exp EPAR .)
    PLUS            reduce using rule 13 (Factor -> SPAR Exp EPAR .)
    MINUS           reduce using rule 13 (Factor -> SPAR Exp EPAR .)
    $end            reduce using rule 13 (Factor -> SPAR Exp EPAR .)
    THEN            reduce using rule 13 (Factor -> SPAR Exp EPAR .)
    EPAR            reduce using rule 13 (Factor -> SPAR Exp EPAR .)
    COMA            reduce using rule 13 (Factor -> SPAR Exp EPAR .)
    ELSE            reduce using rule 13 (Factor -> SPAR Exp EPAR .)
    SEMI            reduce using rule 13 (Factor -> SPAR Exp EPAR .)


state 54

    (4) Exp -> IF Exp THEN Exp . ELSE Exp

    ELSE            shift and go to state 61


state 55

    (5) Exp -> LET MultiDef IN Exp .

    $end            reduce using rule 5 (Exp -> LET MultiDef IN Exp .)
    THEN            reduce using rule 5 (Exp -> LET MultiDef IN Exp .)
    EPAR            reduce using rule 5 (Exp -> LET MultiDef IN Exp .)
    COMA            reduce using rule 5 (Exp -> LET MultiDef IN Exp .)
    ELSE            reduce using rule 5 (Exp -> LET MultiDef IN Exp .)
    SEMI            reduce using rule 5 (Exp -> LET MultiDef IN Exp .)


state 56

    (22) Def -> ID ASSIGN Exp . SEMI

    SEMI            shift and go to state 62


state 57

    (6) Exp -> MAP IdList TO Exp .

    $end            reduce using rule 6 (Exp -> MAP IdList TO Exp .)
    THEN            reduce using rule 6 (Exp -> MAP IdList TO Exp .)
    EPAR            reduce using rule 6 (Exp -> MAP IdList TO Exp .)
    COMA            reduce using rule 6 (Exp -> MAP IdList TO Exp .)
    ELSE            reduce using rule 6 (Exp -> MAP IdList TO Exp .)
    SEMI            reduce using rule 6 (Exp -> MAP IdList TO Exp .)


state 58

    (21) PropIdList -> ID COMA PropIdList .

    TO              reduce using rule 21 (PropIdList -> ID COMA PropIdList .)


state 59

    (9) Term -> Factor SPAR ExpList EPAR .

    SYMBOL          reduce using rule 9 (Term -> Factor SPAR ExpList EPAR .)
    PLUS            reduce using rule 9 (Term -> Factor SPAR ExpList EPAR .)
    MINUS           reduce using rule 9 (Term -> Factor SPAR ExpList EPAR .)
    $end            reduce using rule 9 (Term -> Factor SPAR ExpList EPAR .)
    THEN            reduce using rule 9 (Term -> Factor SPAR ExpList EPAR .)
    EPAR            reduce using rule 9 (Term -> Factor SPAR ExpList EPAR .)
    COMA            reduce using rule 9 (Term -> Factor SPAR ExpList EPAR .)
    ELSE            reduce using rule 9 (Term -> Factor SPAR ExpList EPAR .)
    SEMI            reduce using rule 9 (Term -> Factor SPAR ExpList EPAR .)


state 60

    (18) PropExpList -> Exp COMA . PropExpList
    (17) PropExpList -> . Exp
    (18) PropExpList -> . Exp COMA PropExpList
    (1) Exp -> . Term
    (2) Exp -> . Term Binop
    (3) Exp -> . Term Binop Exp
    (4) Exp -> . IF Exp THEN Exp ELSE Exp
    (5) Exp -> . LET MultiDef IN Exp
    (6) Exp -> . MAP IdList TO Exp
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)
    COMA            reduce using rule 41 (empty -> .)
    EPAR            reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]

    Exp                            shift and go to state 52
    PropExpList                    shift and go to state 63
    Term                           shift and go to state 2
    Unop                           shift and go to state 6
    Factor                         shift and go to state 7
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 61

    (4) Exp -> IF Exp THEN Exp ELSE . Exp
    (1) Exp -> . Term
    (2) Exp -> . Term Binop
    (3) Exp -> . Term Binop Exp
    (4) Exp -> . IF Exp THEN Exp ELSE Exp
    (5) Exp -> . LET MultiDef IN Exp
    (6) Exp -> . MAP IdList TO Exp
    (7) Term -> . Unop Term
    (8) Term -> . Factor
    (9) Term -> . Factor SPAR ExpList EPAR
    (10) Term -> . Empty
    (11) Term -> . INT
    (12) Term -> . Bool
    (26) Unop -> . Sign
    (27) Unop -> . APROX
    (13) Factor -> . SPAR Exp EPAR
    (14) Factor -> . Prim
    (15) Factor -> . ID
    (23) Empty -> . empty
    (24) Bool -> . TRUE
    (25) Bool -> . FALSE
    (28) Sign -> . PLUS
    (29) Sign -> . MINUS
    (32) Prim -> . NUMQ
    (33) Prim -> . FUNCTQ
    (34) Prim -> . LISTQ
    (35) Prim -> . EMPTYQ
    (36) Prim -> . CONSQ
    (37) Prim -> . CONS
    (38) Prim -> . FIRST
    (39) Prim -> . REST
    (40) Prim -> . ARITY
    (41) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    INT             shift and go to state 10
    APROX           shift and go to state 13
    SPAR            shift and go to state 8
    ID              shift and go to state 15
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20
    NUMQ            shift and go to state 21
    FUNCTQ          shift and go to state 22
    LISTQ           shift and go to state 23
    EMPTYQ          shift and go to state 24
    CONSQ           shift and go to state 25
    CONS            shift and go to state 26
    FIRST           shift and go to state 27
    REST            shift and go to state 28
    ARITY           shift and go to state 29
    SYMBOL          reduce using rule 41 (empty -> .)
    $end            reduce using rule 41 (empty -> .)
    THEN            reduce using rule 41 (empty -> .)
    EPAR            reduce using rule 41 (empty -> .)
    COMA            reduce using rule 41 (empty -> .)
    ELSE            reduce using rule 41 (empty -> .)
    SEMI            reduce using rule 41 (empty -> .)

  ! PLUS            [ reduce using rule 41 (empty -> .) ]
  ! MINUS           [ reduce using rule 41 (empty -> .) ]

    Exp                            shift and go to state 64
    Term                           shift and go to state 2
    Unop                           shift and go to state 6
    Factor                         shift and go to state 7
    Empty                          shift and go to state 9
    Bool                           shift and go to state 11
    Sign                           shift and go to state 12
    Prim                           shift and go to state 14
    empty                          shift and go to state 16

state 62

    (22) Def -> ID ASSIGN Exp SEMI .

    ID              reduce using rule 22 (Def -> ID ASSIGN Exp SEMI .)
    IN              reduce using rule 22 (Def -> ID ASSIGN Exp SEMI .)


state 63

    (18) PropExpList -> Exp COMA PropExpList .

    EPAR            reduce using rule 18 (PropExpList -> Exp COMA PropExpList .)


state 64

    (4) Exp -> IF Exp THEN Exp ELSE Exp .

    $end            reduce using rule 4 (Exp -> IF Exp THEN Exp ELSE Exp .)
    THEN            reduce using rule 4 (Exp -> IF Exp THEN Exp ELSE Exp .)
    EPAR            reduce using rule 4 (Exp -> IF Exp THEN Exp ELSE Exp .)
    COMA            reduce using rule 4 (Exp -> IF Exp THEN Exp ELSE Exp .)
    ELSE            reduce using rule 4 (Exp -> IF Exp THEN Exp ELSE Exp .)
    SEMI            reduce using rule 4 (Exp -> IF Exp THEN Exp ELSE Exp .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 3 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 3 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 6 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 6 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 8 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 8 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 30 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 30 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 41 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 41 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 44 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 44 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 45 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 45 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 47 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 47 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 48 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 48 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 60 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 61 resolved as shift
WARNING: reduce/reduce conflict in state 30 resolved using rule (Exp -> Term Binop)
WARNING: rejected rule (empty -> <empty>) in state 30
